---
sidebar_position: 3
---

import func from "../../static/img/WorkFlow.png";

# Engine Layer

The HydroCompute library contains 3 engines for computing and 1 for data transfer. Let's explore each to see how they can be used, and how users can port their own code.

<p align="center">
  <img src={func} alt="func" width="600" />
</p>

## Running the Engines

To run a specific set of functions using different code formats, you can follow these steps:

- Place your code according to the guidelines provided for each engine.
- Put the code in the root directory where the compute library is instantiated.
- Call the engineScripts() method within the instance object to retrieve the available functions and scripts.

:::tip Tip
HydroCompute's engine guidelines can be found within each of the engine for definitions of each script format types.
:::

## JavaScript Engine

The JavaScript engine serves as the main interface for computing in HydroCompute. The code is implemented as objects with defined functions following this structure:

```js
const myCollectionOfFunctions = {
    function1: (data) =>{...},
    function2: (data) => {...},
    main: () => {...}
}
```

The user either select a function from a specific object of functions, or use the `main` function to run.

:::note Note
If the `main` function is being used as point of entry, then the user must assure that it has correct implementation.
:::

### Example 1

In this example, we have a file named `jsExample.js`, which we want to run using the following code:

```js
const compute = new hydroCompute();
compute.data({ data: [1, 2, 3, 4, 5] });
compute.run("jsExample");
```

The `jsExample` file does cubes the values and returns the cube root of the dataset. If everything works correctly, then we just created 1 thread of js code ported directly from your host environment.

## Web Assembly Engine

The Web Assembly (WASM) engine involves .wasm files and glue code generated by various compiled languages. HydroCompute utilizes the glue code generated from different compilers to call the compiled modules upon request.

```js
const compute = new hydroCompute();
compute.data({ data: [1, 2, 3, 4, 5] });
compute.run("wasmExample");
```

<details><summary>Compiling Web Assembly Code</summary>
We are using modular structures to reuse them upon calling, exposing datatypes and memory allocators for manipulating the way to call a function or a script. For that reason, we compile using the following:

```bash
emcc nameOfCFile.c -O3 -o nameOfCFile.js -s MODULARIZE -s EXPORT_ES6=1 -s ALLOW_MEMORY_GROWTH=1
```

For AssemblyScript, use npm for build using:

```bash
asc assembly/nameOfASFile.ts -b build/nameOfASFile/optimized.wasm -t build/nameOfASFile/optimized.wat --sourceMap --validate --optimize
```

</details>

:::note Note
In the initial release, HydroCompute supports C-Emscripten and AssemblyScript-compiled wasm files. Support for additional formats will be added in the future.
:::

### Example 2

To run a WASM example, use the following command:

```js
const compute = new hydroCompute("wasm");
compute.run("wasmExample");
```

## WebGPU Engine

Similar to JavaScript files, WebGPU code is used within the library as a JS object with the following structure:

```js
const myCollectionOfFunctions = {
    function1: (data) =>{...//WGSL Code as string},
    function2: (data) => {...//WGSL Code as string},
    main: () => {...}
}
```

The WebGPU API leverages the available GPU architecture to parallelize work. The engine creates the computing pipeline to optimize the modules.

<details><summary>Developing WebGPU code</summary>

As of the time of this workshop, writing shading code using WebGPU is still not easily achieved, mainly because of the declaration of shader pipelines and correct definition of input and outsputs. Here you can find more information about how to use the [technology](https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API).

</details>

### Example 3

To run a WebGPU example, use the following command:

```js
const compute = new hydroCompute("webgpu");
compute.run("webgpuExample");
```

:::note Note
The WebGPU Engine is mostly tailored towards parallelizable workloads that are often seen when dealing with N-D data. The available scripts within the HydroCompute engine currently support matritial computations, however will be expanded in the future.
:::

## WebRTC Engine

The WebRTC engine aims to leverage this technology to do peer to peer data transfer by exposing the connection and data channels and enabling users who are working with the HydroCompute engine to transfer files using the methods found within.

:::tip Tip
More info about each of the engines can be found in the following links:

- [JS](https://github.com/uihilab/HydroCompute/tree/main/src/javascript)
- [WebGPU](https://github.com/uihilab/HydroCompute/tree/main/src/webgpu)
- [WASM](https://github.com/uihilab/HydroCompute/tree/main/src/wasm)
- [WebRTC](https://github.com/uihilab/HydroCompute/tree/master/src/webrtc)
:::
